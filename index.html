<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">.
    <title>DAA-CP</title> 
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script>
        // Function to toggle the visibility of additional sections
        function toggleInfo(id) {
            var section = document.getElementById(id);
            if (section.style.display === "none" || section.style.display === "") {
                section.style.display = "block";
            } else {
                section.style.display = "none";
            }
        }
    </script>
</head>

<body>
    <!-- Header Section -->
    <header>
        <div class="container">
            <h1>Hello, We are <span class="highlight">Team Urban Navigators</span> üëã</h1>
            <p>We are a passionate team of engineers, exploring Data Analysis and Algorithms through¬†this¬†project.</p> 
        </div>
        
        

    <!-- Projects Section -->
    <section class="projects">
        <div class="container">
            <h2>üöÄCourse Project</h2> 
            <ul>
                <li><strong>Project:</strong> Urban transportation has become a challenge for many city residents, with difficulties in navigating traffic, finding affordable fares, and identifying the shortest routes. These issues often result in wasted time, higher expenses, and frustration for commuters. To address these issues, we have developed a solution that simplifies travel by providing the shortest routes, the most affordable options, and a seamless way to enhance everyday¬†commuting.</li> 
            </ul>
        </div>
    </section>

    <!-- Skills Section -->
    <section class="skills">
        <div class="container">
            <h2>üõ† Skills</h2>
            <ul>
                <li>C, C++, Python</li> 
                <li>Data Structures and Algorithms</li>
                <li>Web Development (React.js, Node.js)</li>
                <li>Problem Solving-Techniques</li>
            </ul>
        </div>
    </section>

       <!-- Portfolio Details Section -->
    <section class="portfolio-details">
        <div class="container">
            <h2>üìö Portfolio Details</h2>
            <div class="details-container">
                <div class="detail-item">
                    <h3 class="detail-title">DAA</h3>
                    <p>Algorithmic Problem Solving</p>
                </div>
                <div class="detail-item">
                    <h3 class="detail-title">Course Code</h3>
                    <p>24ECAC203</p>
                </div>
                <div class="detail-item">
                    <h3 class="detail-title">The Team</h3> 
                    <ul>
                        <li>Aruda G</li> 
                        <li>Bhagya D</li> 
                        <li>S Ganavi</li> 
                        <li>Yash P</li> 
                    </ul>
                </div>
                <div class="detail-item">
                    <h3 class="detail-title">Roll no</h3>
                    <ul>
                        <li>250</li> 
                        <li>228</li> 
                        <li>224</li> 
                        <li>219</li> 
                    </ul>
                </div>
                <div class="detail-item">
                    <h3 class="detail-title">SRN</h3>
                    <ul>
                        <li>01FE23BC059S</li> 
                        <li>01FE23BCS033</li> 
                        <li>01FE23BCS108</li> 
                        <li>01FE23BCS092</li> 
                    </ul>
			<div class="detail-item">
    <h3 class="detail-title">Team Portfolios</h3>
    <ul>
        <li><strong>Aruda G:</strong> <a href="https://sites.google.com/your-link-aruda" target="_blank">Visit Aruda's Site</a></li>
        <li><strong>Bhagya D:</strong> <a href="https://sites.google.com/kletech.ac.in/bhagya-daa/home" target="_blank">Visit Bhagya's Site</a></li>
        <li><strong>S Ganavi:</strong> <a href="https://sites.google.com/kletech.ac.in/daa-portfolio-224/home" target="_blank">Visit Ganavi's Site</a></li>
        <li><strong>Yash P:</strong> <a href="https://sites.google.com/kletech.ac.in/yashdaaportfolio/home" target="_blank">Visit Yash's Site</a></li>
    </ul>
</div>

                </div>
                <div class="detail-item">
                    <h3 class="detail-title">Course Instructor</h3>
                    <p>Vijayalakshmi S</p> 
                </div>
                <div class="detail-item">
                    <h3 class="detail-title">University</h3>
                    <p>KLE Tech University</p>
                </div>
            </div>
        </div>
    </section>

     <!-- Toggle Sections for Course Project--> 
    <button class="button" onclick="toggleInfo('course-intro')">Course Introduction</button>
    <button class="button" onclick="toggleInfo('functionalities used')">Functionalities Used</button>
  

    <section id="course-intro" style="display:none;">
        <h2>Course Introduction</h2>
        <p>Design and Analysis of Algorithms course helped us to learn efficient problem-solving techniques.</p>
        <h3>Course Outcomes</h3>
        <ul>
            <li><strong>Binary Search Tree (BST):</strong> We explored the structure and functionality of BSTs, where each node‚Äôs left child contains smaller values and the right child contains larger values. This structure allows efficient operations like search, insertion, and deletion, particularly in balanced trees.</li>
        <li><strong>Other Trees:</strong>‚Ä¢	AVL Tree: Learned how self-balancing ensures operations by maintaining height balance.
	‚Ä¢	Red-Black Tree: Studied how color-coding (red/black) maintains balance during insertions and deletions.
	‚Ä¢	B-Tree: Understood its importance in databases and file systems for managing large datasets.
	‚Ä¢	Trie: Explored how it enables efficient prefix-based string searching.
	‚Ä¢	N-ary Tree: Discussed its applications in hierarchical data representation, where nodes can have multiple children.</li>
        <li><strong>Breadth-First Search (BFS):</strong>We learned BFS as a level-order traversal technique using a queue, ideal for finding the shortest path in unweighted graphs and solving connectivity problems.</li>
        <li><strong>Depth-First Search (DFS):</strong> We studied DFS as a recursive or stack-based method to explore graph nodes deeply, which is useful for tasks like cycle detection, topological sorting, and connected components.</li>
 <li><strong>Heap:</strong> A heap is a specialized tree-based data structure where the parent node is either greater than (max-heap) or less than (min-heap) its children. Common applications include implementing priority queues¬†and¬†heapsort.</li>
 <li><strong>Pattern Searching:</strong>We explored algorithms like Na√Øve Search, KMP, and Rabin-Karp for finding substrings efficiently in larger texts. These techniques are essential in text processing and computational biology.</li>
 <li><strong>Graph Algorithms:</strong> Graph algorithms are techniques used to solve problems related to graph structures, where data is represented by nodes and edges. Key algorithms include Dijkstra‚Äôs and Bellman-Ford for shortest paths, Kruskal‚Äôs and Prim‚Äôs for minimum spanning trees, and DFS and BFS for graph traversal. These algorithms are crucial in solving problems related to connectivity, optimization, and network analysis across various domains.</li>
 <li><strong>Time Efficiency:</strong> We focused on analyzing the time complexity of algorithms, comparing their best, average, and worst-case performances. This skill helps in selecting optimal algorithms based on input size and constraints.</li>
 </ul>
    </section>

    <section id="functionalities used" style="display:none;">
        <h2>Functionalities Used</h2>
        <table>
            <thead>
                <tr>
                    <th>SLNO</th>
                    <th>Functionality</th>
                    <th>Functionality Description</th>
                    <th>Owner</th>
                    <th>Problem Tools</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                <td>1</td>
                <td>inputTransport</td>
                <td>Efficiently inserts transport data into a sorted list based on arrival time.</td>
                <td>Bhagya</td>
                <td>Insertion Sort</td>
            </tr>
            <tr>
                <td>2</td>
                <td>deleteTransport()</td>
                <td>Deletes a transport entry based on its registration number.</td>
                <td>All</td>
                <td>Linear Search</td>
            </tr>
            <tr>
                <td>3</td>
                <td>findShortestPath()</td>
                <td> Finds the shortest path between two points in the graph.</td>
                <td>Arudha</td>
                <td>Dijkstra‚Äôs Algorithm</td>
            </tr>
            <tr>
                <td>4</td>
                <td>displayScheduleByType()</td>
                <td> Displays schedule for a specific transport type, sorted by arrival time. </td>
                <td>Yash</td>
                <td>Bubble Sort</td>
            </tr>
            <tr>
                <td>5</td>
                <td> findBestRoutePlan()</td>
                <td>Finds the Minimum Spanning Tree (MST) of the city graph for optimal routes.</td>
                <td>Ganavi</td>
                <td>Kruskal‚Äôs Algorithm</td>
            </tr>
            <tr>
                 <td>6</td>
                <td> displayByDestination()</td>
                <td> Finds and displays all transports going to a specific destination.</td>
                <td>Aruda</td>
                <td> KMP Algorithm</td>
            </tr>
            <tr>
                <td>7</td>
                <td>findAllPathsDFS()</td>
                <td>Finds and displays all possible paths from one point to another in the city graph.</td>
                <td>Yash</td>
                <td>DFS</td>
            </tr>
            <tr>
                <td>8</td>
                <td>displayImmediateConnections()</td>
                <td> Displays all immediate connections for a given source point.</td>
                <td>Bhagya</td>
                <td>DFS</td>
            </tr>
            <tr>
                <td>9</td>
                <td> displayLeastCostTransport()</td>
                <td>Displays the transport with the least cost for a given destination.</td>
                <td>Ganavi</td>
                <td>Boyer-Moore</td>
            </tr>
             </tbody>
        </table>
    </section>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDGs in Code</title>
   <style>
    table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    th {
        background-color: #4CAF50;
        color: white;
    }
    tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    tr:hover {
        background-color: #f1f1f1;
    }
    pre {
        background: #f4f4f4;
        padding: 10px;
        border: 1px solid #ddd;
        overflow: auto;
        color: black; /* Change the text color to black */
    }
</style>
</head>
<body>
	 

    <!-- Your content goes here -->

    <button class="button" onclick="toggleInfo('sdg-goals')">SDGs Reflected</button>

    <section id="sdg-goals" style="display:none;">
        <h2>SDGs Addressed in the Code</h2>
        <table>
            <thead>
                <tr>
                    <th>SDG</th>
                    <th>Goal Name</th>
                    <th>Relevance to the Code</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>SDG 9</strong></td>
                    <td>Industry, Innovation, and Infrastructure</td>
                    <td>Algorithms like <strong>Dijkstra‚Äôs Algorithm</strong> and <strong>Kruskal‚Äôs Algorithm</strong> optimize transportation routes and infrastructure planning, contributing to sustainable and efficient infrastructure development.</td>
                </tr>
                <tr>
                    <td><strong>SDG 11</strong></td>
                    <td>Sustainable Cities and Communities</td>
                    <td>Functions such as <strong>findBestRoutePlan</strong> and <strong>findShortestPath</strong> support better urban transportation systems, improving accessibility and reducing congestion.</td>
                </tr>
                <tr>
                    <td><strong>SDG 13</strong></td>
                    <td>Climate Action</td>
                    <td>Efficient transportation planning and routing algorithms reduce fuel consumption and emissions, contributing to environmentally friendly transport systems.</td>
                </tr>
                <tr>
                    <td><strong>SDG 8</strong></td>
                    <td>Decent Work and Economic Growth</td>
                    <td>Optimized transportation and scheduling systems can improve logistics, boost trade efficiency, and create economic growth opportunities.</td>
                </tr>
                <tr>
                    <td><strong>SDG 12</strong></td>
                    <td>Responsible Consumption and Production</td>
                    <td>Efficient scheduling and routing reduce resource wastage, ensuring responsible usage of resources in transportation systems.</td>
                </tr>
            </tbody>
        </table>
    </section>

    <div class="code-section">
        <button onclick="toggleCode()">Show C++ Code</button>
        <pre id="cppCode" style="display:none;">
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <queue>
#include <climits>
#include <algorithm>
using namespace std;

struct Transport {
    string regNo;       // Registration number
    string type;        // Type of transport
    double cost;        // Cost of transport
    string destination; // Destination
    string arrivalTime; // Arrival time
};

struct Edge {
    string src, dest;
    double weight;
};

class TransportSystem {
private:
    vector<Transport> transports; // Vector to store transport data
    vector<Edge> edges;           // To store the graph as a list of edges

    // Graph represented as an adjacency list
    map<string, list<pair<string, double>>> cityGraph;

    // Helper functions for Union-Find
    map<string, string> parent; // Parent map for union-find
    map<string, int> rank;      // Rank map for union-find

    void makeSet(const string& node) {
        parent[node] = node;
        rank[node] = 0;
    }

    string findSet(const string& node) {
        if (parent[node] != node) {
            parent[node] = findSet(parent[node]); // Path compression
        }
        return parent[node];
    }

    void unionSets(const string& node1, const string& node2) {
        string root1 = findSet(node1);
        string root2 = findSet(node2);

        if (root1 != root2) {
            if (rank[root1] < rank[root2]) {
                parent[root1] = root2;
            } else if (rank[root1] > rank[root2]) {
                parent[root2] = root1;
            } else {
                parent[root2] = root1;
                rank[root1]++;
            }
        }
    }

    // KMP Helper function to build the prefix table
    vector<int> buildPrefixTable(const string& pattern) {
        vector<int> prefixTable(pattern.size(), 0);
        int j = 0;
        for (int i = 1; i < pattern.size(); ++i) {
            while (j > 0 && pattern[i] != pattern[j]) {
                j = prefixTable[j - 1];
            }
            if (pattern[i] == pattern[j]) {
                j++;
            }
            prefixTable[i] = j;
        }
        return prefixTable;
    }

    // KMP Algorithm to find if a pattern exists in a text
    bool KMP(const string& text, const string& pattern) {
        if (pattern.empty()) return true;
        vector<int> prefixTable = buildPrefixTable(pattern);
        int j = 0;
        for (int i = 0; i < text.size(); ++i) {
            while (j > 0 && text[i] != pattern[j]) {
                j = prefixTable[j - 1];
            }
            if (text[i] == pattern[j]) {
                j++;
            }
            if (j == pattern.size()) {
                return true;
            }
        }
        return false;
    }
        // DFS Helper function to find all paths
    void DFS(const string& current, const string& destination, map<string, bool>& visited, vector<string>& path, vector<vector<string>>& allPaths) {
        visited[current] = true;
        path.push_back(current);

        if (current == destination) {
            allPaths.push_back(path);
        } else {
            for (const auto& neighbor : cityGraph[current]) {
                if (!visited[neighbor.first]) {
                    DFS(neighbor.first, destination, visited, path, allPaths);
                }
            }
        }

        path.pop_back();
        visited[current] = false;
    }
        // Boyer-Moore algorithm for pattern matching
    map<char, int> buildBadCharTable(const string& pattern) {
        map<char, int> badCharTable;
        for (int i = 0; i < pattern.size(); i++) {
            badCharTable[pattern[i]] = i;
        }
        return badCharTable;
    }

    bool boyerMooreSearch(const string& text, const string& pattern) {
        int m = pattern.size();
        int n = text.size();
        if (m > n) return false;

        map<char, int> badCharTable = buildBadCharTable(pattern);
        int shift = 0;

        while (shift <= (n - m)) {
            int j = m - 1;

            while (j >= 0 && pattern[j] == text[shift + j]) {
                j--;
            }

            if (j < 0) {
                return true;
            } else {
                char badChar = text[shift + j];
                shift += max(1, j - (badCharTable.count(badChar) ? badCharTable[badChar] : -1));
            }
        }
        return false;
    }

public:
    TransportSystem() {
        // Define the city graph with given routes
        cityGraph["A"] = {{"B", 3}, {"C", 4}};
        cityGraph["B"] = {{"A", 3}, {"C", 5}, {"D", 4}, {"E", 3}};
        cityGraph["C"] = {{"A", 4}, {"B", 5}, {"D", 1}};
        cityGraph["D"] = {{"B", 4}, {"C", 1}, {"F", 4}, {"E", 1}};
        cityGraph["E"] = {{"B", 3}, {"D", 1}, {"F", 1}};
        cityGraph["F"] = {{"D", 4}, {"E", 1}};

        // Add edges to the graph
        edges = {
            {"A", "B", 3}, {"A", "C", 4},
            {"B", "C", 5}, {"B", "D", 4}, {"B", "E", 3},
            {"C", "D", 1},
            {"D", "F", 4}, {"D", "E", 1},
            {"E", "F", 1}
        };
    }

    // Function to add transport information using insertion sort to maintain order by arrival time
    void inputTransport() {
        Transport newTransport;
        cout << "Enter registration number: ";
        cin.ignore();
        getline(cin, newTransport.regNo);
        cout << "Enter transport type: ";
        getline(cin, newTransport.type);
        cout << "Enter cost of transport: ";
        cin >> newTransport.cost;
        cin.ignore();
        cout << "Enter destination: ";
        getline(cin, newTransport.destination);
        cout << "Enter arrival time: ";
        getline(cin, newTransport.arrivalTime);

        // Insert the transport into the sorted vector using insertion sort
        auto it = transports.begin();
        while (it != transports.end() && it->arrivalTime <= newTransport.arrivalTime) {
            ++it;
        }
        transports.insert(it, newTransport);

        cout << "Transport added successfully and sorted by arrival time!\n";
    }

    // Function to delete transport by registration number
    void deleteTransport() {
        string regNo;
        cout << "Enter the registration number to delete: ";
        cin.ignore();
        getline(cin, regNo);

        // Find and remove transport with matching registration number
        bool found = false;
        for (auto it = transports.begin(); it != transports.end(); ++it) {
            if (it->regNo == regNo) {
                transports.erase(it);
                found = true;
                cout << "Transport with registration number " << regNo << " deleted successfully!\n";
                break;
            }
        }

        if (!found) {
            cout << "Transport with registration number " << regNo << " not found!\n";
        }
    }

    // Function to display all transports
    void displayTransports() {
        if (transports.empty()) {
            cout << "No transports available!\n";
            return;
        }

        cout << "\nAll Transport Details:\n";
        for (const auto& transport : transports) {
            cout << "RegNo: " << transport.regNo << ", Type: " << transport.type
                 << ", Cost: " << transport.cost << ", Destination: " << transport.destination
                 << ", Arrival Time: " << transport.arrivalTime << endl;
        }
    }

    // Function to display the predefined city graph (routes)
    void displayCityGraph() {
        cout << "\nCity Routes (Graph):\n";
        for (const auto& place : cityGraph) {
            cout << place.first << " is connected to:\n";
            for (const auto& route : place.second) {
                cout << "  - " << route.first << " with distance " << route.second << " km\n";
            }
        }
    }

    // Function to find the shortest path using Dijkstra's Algorithm
    void findShortestPath(const string& start, const string& end) {
        // Min-heap priority queue to store (distance, node)
        priority_queue<pair<double, string>, vector<pair<double, string>>, greater<pair<double, string>>> pq;

        // Distance map to store the shortest distance to each node
        map<string, double> distances;

        // Initialize distances to infinity
        for (const auto& place : cityGraph) {
            distances[place.first] = INT_MAX;
        }

        // Set the distance to the start node as 0 and push it to the queue
        distances[start] = 0;
        pq.push({0, start});

        while (!pq.empty()) {
            auto [currentDist, currentNode] = pq.top();
            pq.pop();

            // Iterate over neighbors of the current node
            for (const auto& neighbor : cityGraph[currentNode]) {
                string neighborNode = neighbor.first;
                double edgeWeight = neighbor.second;

                // Calculate new distance
                double newDist = currentDist + edgeWeight;
                if (newDist < distances[neighborNode]) {
                    distances[neighborNode] = newDist;
                    pq.push({newDist, neighborNode});
                }
            }
        }

        // Output the shortest distance
        if (distances[end] == INT_MAX) {
            cout << "No path exists from " << start << " to " << end << ".\n";
        } else {
            cout << "The shortest distance from " << start << " to " << end << " is: " << distances[end] << " km.\n";
        }
    }

    // Function to display schedule of a specific transport type sorted by arrival time using bubble sort
    void displayScheduleByType() {
        string type;
        cout << "Enter the transport type to display schedule: ";
        cin.ignore();
        getline(cin, type);

        vector<Transport> filteredTransports;

        // Filter transports by the given type
        for (const auto& transport : transports) {
            if (transport.type == type) {
                filteredTransports.push_back(transport);
            }
        }

        if (filteredTransports.empty()) {
            cout << "No transports of type " << type << " found!\n";
            return;
        }

        // Bubble sort the filtered transports by arrival time
        for (size_t i = 0; i < filteredTransports.size() - 1; ++i) {
            for (size_t j = 0; j < filteredTransports.size() - i - 1; ++j) {
                if (filteredTransports[j].arrivalTime > filteredTransports[j + 1].arrivalTime) {
                    swap(filteredTransports[j], filteredTransports[j + 1]);
                }
            }
        }

        // Display the sorted schedule
        cout << "\nSchedule for transport type " << type << ":\n";
        for (const auto& transport : filteredTransports) {
            cout << "RegNo: " << transport.regNo << ", Cost: " << transport.cost
                 << ", Destination: " << transport.destination
                 << ", Arrival Time: " << transport.arrivalTime << endl;
        }
    }

    // Function to find the Minimum Spanning Tree (MST) using Kruskal's algorithm
    void findBestRoutePlan() {
        // Sort edges by weight
        sort(edges.begin(), edges.end(), [](const Edge& e1, const Edge& e2) {
            return e1.weight < e2.weight;
        });

        // Initialize Union-Find structure
        for (const auto& edge : edges) {
            makeSet(edge.src);
            makeSet(edge.dest);
        }

        // Perform Kruskal's algorithm
        vector<Edge> mst;
        for (const auto& edge : edges) {
            if (findSet(edge.src) != findSet(edge.dest)) {
                mst.push_back(edge);
                unionSets(edge.src, edge.dest);
            }
        }

        // Display the MST
        cout << "\nBest Route Plan (Minimum Spanning Tree):\n";
        for (const auto& edge : mst) {
            cout << edge.src << " - " << edge.dest << " : " << edge.weight << " km\n";
        }
    }

    // Function to display all transports with a specific destination using KMP algorithm
    void displayByDestination()
    {
        string destination;
        cout << "Enter destination to search: ";
        cin.ignore();
        getline(cin, destination);

        bool found = false;
        cout << "\nTransports going to destination containing \"" << destination << "\":\n";
        for (const auto& transport : transports) {
            if (KMP(transport.destination, destination)) {
                cout << "RegNo: " << transport.regNo << ", Type: " << transport.type
                     << ", Cost: " << transport.cost << ", Destination: " << transport.destination
                     << ", Arrival Time: " << transport.arrivalTime << endl;
                found = true;
            }
        }

        if (!found) {
            cout << "No transports found for the specified destination.\n";
        }
    }
     // Function to find all possible ways from source to destination using DFS
    void findAllPathsDFS(const string& start, const string& end) {
        map<string, bool> visited;
        vector<string> path;
        vector<vector<string>> allPaths;

        DFS(start, end, visited, path, allPaths);

        cout << "\nAll possible paths from " << start << " to " << end << ":\n";
        for (const auto& p : allPaths) {
            for (const auto& node : p) {
                cout << node << " ";
            }
            cout << endl;
        }

        if (allPaths.empty()) {
            cout << "No path exists from " << start << " to " << end << ".\n";
        }
    }

         // Function to display immediate places connected to a source using BFS
    void displayImmediateConnections(const string& start) {
        if (cityGraph.find(start) == cityGraph.end()) {
            cout << "Invalid source point." << endl;
            return;
        }

        cout << "\nImmediate connections from " << start << " (" << getPlaceName(start) << "):\n";
        for (const auto& neighbor : cityGraph[start]) {
            cout << neighbor.first << " (" << getPlaceName(neighbor.first) << ")\n";
        }
    }

    string getPlaceName(const string& code) {
        if (code == "A") return "Railway Station";
        if (code == "B") return "Bus Stand";
        if (code == "C") return "Central Market";
        if (code == "D") return "Mall";
        if (code == "E") return "Corporation";
        if (code == "F") return "Amusement Park";
        return "Unknown";
    }
  // Function to display the transport with the least cost for a specific destination
    void displayLeastCostTransport()
    {
        string destination;
        cout << "Enter destination to search for least cost transport: ";
        cin.ignore();
        getline(cin, destination);

        double minCost = INT_MAX;
        Transport leastCostTransport;
        bool found = false;

        for (const auto& transport : transports) {
            if (boyerMooreSearch(transport.destination, destination)) {
                if (transport.cost < minCost) {
                    minCost = transport.cost;
                    leastCostTransport = transport;
                    found = true;
                }
            }
        }

        if (found) {
            cout << "\nLeast Cost Transport to " << destination << ":\n";
            cout << "RegNo: " << leastCostTransport.regNo << ", Type: " << leastCostTransport.type
                 << ", Cost: " << leastCostTransport.cost << ", Destination: " << leastCostTransport.destination
                 << ", Arrival Time: " << leastCostTransport.arrivalTime << endl;
        } else {
            cout << "No transport found for the specified destination." << endl;
        }
    }
};
int main() {
    TransportSystem system;
    int choice;

    do {
        cout << "\nMenu:\n";
        cout << "1. Input Transport\n";
        cout << "2. Delete Transport by Registration Number\n";
        cout << "3. Display All Transports\n";
        cout << "4. Display City Graph\n";
        cout << "5. Find Shortest Path (Dijkstra's Algorithm)\n";
        cout << "6. Display Schedule by Transport Type\n";
        cout << "7. Find Best Route Plan (Kruskal's Algorithm)\n";
        cout << "8. Display Transports by Destination (KMP Algorithm)\n";
        cout << "9. Find All Possible Paths (DFS)\n";
        cout << "10. Display Immediate Connections (BFS)\n";
        cout << "11. Display Least Cost Transport to Destination (Boyer-Moore Algorithm)\n";
        cout << "0. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                system.inputTransport();
                break;
            case 2:
                system.deleteTransport();
                break;
            case 3:
                system.displayTransports();
                break;
            case 4:
                system.displayCityGraph();
                break;
            case 5: {
                string start, end;
                cout << "Enter start point (e.g., A, B, C): ";
                cin >> start;
                cout << "Enter end point (e.g., A, B, C): ";
                cin >> end;
                system.findShortestPath(start, end);
                break;
            }
            case 6:
                system.displayScheduleByType();
                break;
            case 7:
                system.findBestRoutePlan();
                break;
            case 8:
                system.displayByDestination();
                break;
            case 9: {
                string start, end;
                cout << "Enter start point (e.g., A, B, C): ";
                cin >> start;
                cout << "Enter end point (e.g., A, B, C): ";
                cin >> end;
                system.findAllPathsDFS(start, end);
                break;
            }
            case 10: {
                string start;
                cout << "Enter source point (e.g., A, B, C): ";
                cin >> start;
                system.displayImmediateConnections(start);
                break;
            }
            case 11:
                system.displayLeastCostTransport();
                break;
            case 0:
                cout << "Exiting the program.\n";
                break;
            default:
                cout << "Invalid choice! Please try again.\n";
                break;
        }
    } while (choice != 0);

    return 0;
}
        </pre>
    </div>

    <!-- WebAssembly JavaScript Glue -->
    <script src="your_output.js"></script>

    <div id="cpp-output">
        <button onclick="runCppCode()">Run C++ Code</button>
        <pre id="cppResult"></pre>
    </div>

    <script>
        // Run the C++ code via WebAssembly
        function runCppCode() {
            if (typeof Module !== 'undefined' && Module.onRuntimeInitialized) {
                Module.onRuntimeInitialized = function() {
                    // Call the C++ function (main function)
                    Module._main(); // Or whatever your function is
                };
            } else {
                console.error('WebAssembly module not loaded.');
            }
        }

        function toggleCode() {
            const codeBlock = document.getElementById('cppCode');
            codeBlock.style.display = codeBlock.style.display === 'none' ? 'block' : 'none';
        }

        // Toggle SDGs section
        function toggleInfo(id) {
            const section = document.getElementById(id);
            if (section.style.display === "none" || section.style.display === "") {
                section.style.display = "block";
            } else {
                section.style.display = "none";
            }
        }
    </script>

    <!-- Footer -->
    <footer>
        <blockquote>‚ÄúBecause a Smart City deserves smarter commutes‚Äù</blockquote>
        <p>&copy; DAA Course Project | Designed by Students of KLE Technological University</p>
    </footer>
</body>
</html>
